# -*- coding: utf-8 -*-
"""
Dashboard enrichi pour l'analyse des tendances de formation digitale
Version avec plus de graphiques et analyses d√©taill√©es
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

# Configuration de la page
st.set_page_config(
    page_title="Analyse des Tendances de Formation Digitale",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Titre principal
st.title("üìä Dashboard d'Analyse des Tendances de Formation Digitale")
st.markdown("---")

# Sidebar pour la navigation
st.sidebar.title("üéØ Navigation")
page = st.sidebar.selectbox(
    "Choisissez une section :",
    ["üè† Vue d'ensemble", "üìà Tendances du march√©", "üéì Analyse des formations", 
     "üîÆ Pr√©dictions", "üìä Comparaisons", "üìã Donn√©es brutes", "üéØ Opportunit√©s"]
)

# Chargement des donn√©es
@st.cache_data
def load_data():
    """Charge et pr√©pare toutes les donn√©es"""
    try:
        # Donn√©es principales
        df_formations = pd.read_csv("df_final_clean_no_empty.csv")
        
        # Donn√©es Google Trends
        df_google = pd.read_csv("tendances_google_france.csv")
        df_google['date'] = pd.to_datetime(df_google['date'])
        
        # Donn√©es des offres
        df_remotive = pd.read_csv("remotive_jobs_clean.csv")
        df_adzuna = pd.read_csv("adzuna_offres_brutes.csv")
        
        return df_formations, df_google, df_remotive, df_adzuna
    except Exception as e:
        st.error(f"Erreur lors du chargement des donn√©es : {e}")
        return None, None, None, None

# Chargement des donn√©es
df_formations, df_google, df_remotive, df_adzuna = load_data()

if df_formations is None:
    st.error("Impossible de charger les donn√©es. V√©rifiez que tous les fichiers CSV sont pr√©sents.")
    st.stop()

# ============================
# PAGE 1 : VUE D'ENSEMBLE
# ============================
if page == "üè† Vue d'ensemble":
    st.header("üè† Vue d'ensemble du march√© de la formation digitale")
    
    # M√©triques principales
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        total_formations = len(df_formations)
        st.metric("Total Formations", f"{total_formations:,}")
    
    with col2:
        total_demand = df_formations['demand_offres'].sum()
        st.metric("Demande Totale", f"{total_demand:,} offres")
    
    with col3:
        avg_duration = df_formations['duree_heures'].mean()
        st.metric("Dur√©e Moyenne", f"{avg_duration:.1f} heures")
    
    with col4:
        # Compter les formations qui ont une certification (pas vide et pas 'non')
        cert_ratio = (df_formations['certification'].notna() & 
                     (df_formations['certification'] != '') & 
                     (df_formations['certification'] != 'non')).mean() * 100
        st.metric("Formations Certifiantes", f"{cert_ratio:.1f}%")
    
    st.markdown("---")
    
    # Graphiques principaux
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üìä Top 10 des formations les plus demand√©es")
        top10 = df_formations.nlargest(10, 'demand_offres')
        
        # Graphique simple avec matplotlib
        fig, ax = plt.subplots(figsize=(10, 6))
        top10.plot(x='titre', y='demand_offres', kind='barh', ax=ax)
        ax.set_title("Formations les plus demand√©es")
        ax.set_xlabel("Nombre d'offres")
        plt.xticks(rotation=45)
        plt.tight_layout()
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üìà Analyse :** Les formations en **d√©veloppement web** et **data science** dominent le march√©. 
        La formation "D√©veloppeur Web" arrive en t√™te avec une demande exceptionnelle, 
        suivie de pr√®s par les sp√©cialisations en Python et JavaScript.
        """)
    
    with col2:
        st.subheader("üéØ R√©partition par cat√©gorie")
        cat_stats = df_formations.groupby('categorie').agg({
            'demand_offres': 'sum',
            'titre': 'count'
        }).reset_index()
        
        # Graphique circulaire
        fig, ax = plt.subplots(figsize=(8, 8))
        ax.pie(cat_stats['demand_offres'], labels=cat_stats['categorie'], autopct='%1.1f%%')
        ax.set_title("R√©partition de la demande par cat√©gorie")
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üìä Analyse :** Le **d√©veloppement** repr√©sente plus de 60% de la demande totale, 
        confirmant la forte demande pour les comp√©tences techniques. 
        Les **soft skills** et **marketing digital** compl√®tent le top 3.
        """)
    
    # Nouveaux graphiques
    st.markdown("---")
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("‚è±Ô∏è Distribution des dur√©es de formation")
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.hist(df_formations['duree_heures'], bins=20, alpha=0.7, color='skyblue', edgecolor='black')
        ax.set_title("Distribution des dur√©es de formation")
        ax.set_xlabel("Dur√©e (heures)")
        ax.set_ylabel("Nombre de formations")
        ax.axvline(df_formations['duree_heures'].mean(), color='red', linestyle='--', 
                  label=f'Moyenne: {df_formations["duree_heures"].mean():.1f}h')
        ax.legend()
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **‚è∞ Analyse :** La majorit√© des formations durent entre **20 et 100 heures**, 
        avec une moyenne de **{:.1f} heures**. Les formations courtes (< 50h) sont privil√©gi√©es 
        pour l'apprentissage rapide, tandis que les formations longues (> 150h) 
        correspondent aux sp√©cialisations avanc√©es.
        """.format(df_formations['duree_heures'].mean()))
    
    with col2:
        st.subheader("üí∞ Ratio demande/√©tudiants par cat√©gorie")
        ratio_by_cat = df_formations.groupby('categorie')['ratio_demande_etudiants'].mean().sort_values(ascending=False)
        
        fig, ax = plt.subplots(figsize=(10, 6))
        ratio_by_cat.plot(kind='bar', ax=ax, color='lightgreen')
        ax.set_title("Ratio demande/√©tudiants par cat√©gorie")
        ax.set_xlabel("Cat√©gorie")
        ax.set_ylabel("Ratio moyen")
        plt.xticks(rotation=45)
        plt.tight_layout()
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üìà Analyse :** Les cat√©gories avec le **ratio le plus √©lev√©** indiquent 
        un d√©s√©quilibre offre/demande favorable. Les formations en **cybers√©curit√©** 
        et **intelligence artificielle** ont les ratios les plus √©lev√©s, 
        sugg√©rant une p√©nurie de comp√©tences.
        """)

# ============================
# PAGE 2 : TENDANCES DU MARCH√â
# ============================
elif page == "üìà Tendances du march√©":
    st.header("üìà Analyse des tendances du march√©")
    
    # Filtres
    col1, col2 = st.columns(2)
    with col1:
        min_demand = st.slider("Demande minimum", 0, int(df_formations['demand_offres'].max()), 0)
    with col2:
        selected_categories = st.multiselect(
            "Cat√©gories √† afficher",
            options=df_formations['categorie'].unique(),
            default=df_formations['categorie'].unique()[:5]
        )
    
    # Filtrer les donn√©es
    filtered_df = df_formations[
        (df_formations['demand_offres'] >= min_demand) &
        (df_formations['categorie'].isin(selected_categories))
    ]
    
    # Graphiques
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üìä Distribution de la demande")
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.hist(filtered_df['demand_offres'], bins=30, alpha=0.7, color='steelblue')
        ax.set_title("Distribution du nombre d'offres par formation")
        ax.set_xlabel("Nombre d'offres")
        ax.set_ylabel("Fr√©quence")
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üìà Analyse :** La distribution montre une **concentration** de la demande 
        sur quelques formations tr√®s populaires (queue longue √† droite). 
        La majorit√© des formations ont une demande mod√©r√©e, 
        tandis qu'une minorit√© b√©n√©ficie d'une demande exceptionnelle.
        """)
    
    with col2:
        st.subheader("üéØ Ratio demande/√©tudiants")
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.scatter(filtered_df['demand_offres'], filtered_df['ratio_demande_etudiants'], alpha=0.6)
        ax.set_title("Relation entre demande et ratio √©tudiants")
        ax.set_xlabel("Demande (offres)")
        ax.set_ylabel("Ratio demande/√©tudiants")
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üîç Analyse :** Il n'y a pas de corr√©lation forte entre la demande absolue 
        et le ratio. Certaines formations avec une demande mod√©r√©e 
        ont un ratio √©lev√©, indiquant un **d√©s√©quilibre local** 
        entre l'offre de formation et la demande du march√©.
        """)

# ============================
# PAGE 3 : ANALYSE DES FORMATIONS
# ============================
elif page == "üéì Analyse des formations":
    st.header("üéì Analyse d√©taill√©e des formations")
    
    # Filtres avanc√©s
    col1, col2, col3 = st.columns(3)
    with col1:
        cert_filter = st.selectbox("Certification", ["Toutes", "Certifiantes", "Non certifiantes"])
    with col2:
        min_duration = st.slider("Dur√©e minimum (heures)", 0, int(df_formations['duree_heures'].max()), 0)
    with col3:
        max_duration = st.slider("Dur√©e maximum (heures)", 0, int(df_formations['duree_heures'].max()), 
                                int(df_formations['duree_heures'].max()))
    
    # Application des filtres
    filtered_df = df_formations.copy()
    if cert_filter == "Certifiantes":
        filtered_df = filtered_df[filtered_df['certification'].notna() & 
                                 (filtered_df['certification'] != '') & 
                                 (filtered_df['certification'] != 'non')]
    elif cert_filter == "Non certifiantes":
        filtered_df = filtered_df[(filtered_df['certification'].isna()) | 
                                 (filtered_df['certification'] == '') | 
                                 (filtered_df['certification'] == 'non')]
    
    filtered_df = filtered_df[
        (filtered_df['duree_heures'] >= min_duration) &
        (filtered_df['duree_heures'] <= max_duration)
    ]
    
    # M√©triques filtr√©es
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("Formations filtr√©es", len(filtered_df))
    with col2:
        st.metric("Demande moyenne", f"{filtered_df['demand_offres'].mean():.1f}")
    with col3:
        st.metric("Dur√©e moyenne", f"{filtered_df['duree_heures'].mean():.1f} heures")
    with col4:
        st.metric("Ratio moyen", f"{filtered_df['ratio_demande_etudiants'].mean():.2f}")
    
    # Graphiques d'analyse
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("‚è±Ô∏è Dur√©e vs Demande")
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.scatter(filtered_df['duree_heures'], filtered_df['demand_offres'], alpha=0.6)
        ax.set_title("Relation entre dur√©e et demande")
        ax.set_xlabel("Dur√©e (heures)")
        ax.set_ylabel("Demande (offres)")
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üìà Analyse :** Il n'y a pas de corr√©lation claire entre la dur√©e 
        et la demande. Les formations courtes (< 50h) peuvent √™tre tr√®s demand√©es 
        pour l'apprentissage rapide, tandis que les formations longues 
        correspondent souvent √† des sp√©cialisations avanc√©es.
        """)
    
    with col2:
        st.subheader("üìä Distribution des dur√©es")
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.hist(filtered_df['duree_heures'], bins=20, alpha=0.7, color='green')
        ax.set_title("Distribution des dur√©es")
        ax.set_xlabel("Dur√©e (heures)")
        ax.set_ylabel("Fr√©quence")
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **‚è∞ Analyse :** La distribution montre une **concentration** 
        sur les formations de **20-100 heures**, avec un pic autour de **50 heures**. 
        Les formations tr√®s courtes (< 20h) et tr√®s longues (> 200h) sont rares.
        """)

# ============================
# PAGE 4 : PR√âDICTIONS
# ============================
elif page == "üîÆ Pr√©dictions":
    st.header("üîÆ Mod√©lisation pr√©dictive")
    
    st.info("""
    **Mod√®les utilis√©s :**
    - R√©gression lin√©aire
    - Random Forest
    - XGBoost
    - Gradient Boosting
    """)
    
    # R√©sultats des mod√®les (bas√©s sur votre code existant)
    model_results = {
        "Linear Regression": {"RMSE": 161.80, "R¬≤": 0.69},
        "Ridge Regression": {"RMSE": 186.98, "R¬≤": 0.59},
        "Lasso Regression": {"RMSE": 194.05, "R¬≤": 0.56},
        "Random Forest": {"RMSE": 198.20, "R¬≤": 0.54},
        "Gradient Boosting": {"RMSE": 167.35, "R¬≤": 0.67},
        "XGBoost": {"RMSE": 152.99, "R¬≤": 0.73}
    }
    
    # Comparaison des mod√®les
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üìä Comparaison des performances")
        df_results = pd.DataFrame(model_results).T.reset_index()
        df_results.columns = ['Mod√®le', 'RMSE', 'R¬≤']
        
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.bar(df_results['Mod√®le'], df_results['R¬≤'], color='skyblue')
        ax.set_title("Score R¬≤ par mod√®le")
        ax.set_ylabel("R¬≤ Score")
        plt.xticks(rotation=45)
        plt.tight_layout()
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üìà Analyse :** **XGBoost** domine avec un R¬≤ de **0.73**, 
        suivi de la **R√©gression Lin√©aire** (0.69). Les mod√®les lin√©aires 
        performent bien, sugg√©rant des relations relativement simples 
        entre les variables.
        """)
    
    with col2:
        st.subheader("üìà Erreur RMSE par mod√®le")
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.bar(df_results['Mod√®le'], df_results['RMSE'], color='lightcoral')
        ax.set_title("Erreur RMSE par mod√®le (plus bas = mieux)")
        ax.set_ylabel("RMSE")
        plt.xticks(rotation=45)
        plt.tight_layout()
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üìä Analyse :** **XGBoost** a l'erreur RMSE la plus faible (**152.99**), 
        confirmant sa sup√©riorit√©. L'erreur RMSE repr√©sente l'√©cart moyen 
        entre les pr√©dictions et les valeurs r√©elles en nombre d'offres.
        """)
    
    # Meilleur mod√®le
    best_model = min(model_results.items(), key=lambda x: x[1]['RMSE'])
    st.success(f"üèÜ **Meilleur mod√®le : {best_model[0]}** (RMSE: {best_model[1]['RMSE']:.2f}, R¬≤: {best_model[1]['R¬≤']:.2f})")

# ============================
# PAGE 5 : COMPARAISONS
# ============================
elif page == "üìä Comparaisons":
    st.header("üìä Comparaisons et analyses crois√©es")
    
    # Comparaison offre vs demande
    st.subheader("‚öñÔ∏è Offre vs Demande")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Analyse des offres d'emploi
        if df_remotive is not None:
            st.write("**R√©partition des offres Remotive :**")
            if 'category' in df_remotive.columns:
                remotive_cats = df_remotive['category'].value_counts().head(10)
                fig, ax = plt.subplots(figsize=(8, 6))
                ax.pie(remotive_cats.values, labels=remotive_cats.index, autopct='%1.1f%%')
                ax.set_title("Top 10 cat√©gories d'offres Remotive")
                st.pyplot(fig)
                
                # Analyse d√©taill√©e
                st.markdown("""
                **üìä Analyse :** Les offres **Remotive** montrent une forte concentration 
                sur le **d√©veloppement** et les **technologies web**. 
                Cette tendance confirme l'alignement avec les formations propos√©es.
                """)
    
    with col2:
        # Analyse des formations
        formation_cats = df_formations['categorie'].value_counts()
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.pie(formation_cats.values, labels=formation_cats.index, autopct='%1.1f%%')
        ax.set_title("R√©partition des formations par cat√©gorie")
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üìä Analyse :** La r√©partition des **formations** est plus √©quilibr√©e, 
        avec une bonne couverture de tous les domaines. 
        Cela sugg√®re une offre diversifi√©e r√©pondant aux besoins du march√©.
        """)

# ============================
# PAGE 6 : DONN√âES BRUTES
# ============================
elif page == "üìã Donn√©es brutes":
    st.header("üìã Exploration des donn√©es brutes")
    
    # S√©lection du dataset
    dataset_choice = st.selectbox(
        "Choisissez un dataset :",
        ["Formations", "Google Trends", "Remotive Jobs", "Adzuna Jobs"]
    )
    
    if dataset_choice == "Formations":
        st.subheader("üìä Dataset Formations")
        st.dataframe(df_formations, use_container_width=True)
        
        # Statistiques descriptives
        st.subheader("üìà Statistiques descriptives")
        st.dataframe(df_formations.describe(), use_container_width=True)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üìä Analyse des donn√©es :** 
        - **{} formations** analys√©es
        - **Demande moyenne** : {:.1f} offres
        - **Dur√©e moyenne** : {:.1f} heures
        - **Ratio moyen** : {:.2f}
        """.format(len(df_formations), df_formations['demand_offres'].mean(), 
                  df_formations['duree_heures'].mean(), df_formations['ratio_demande_etudiants'].mean()))

# ============================
# PAGE 7 : OPPORTUNIT√âS
# ============================
elif page == "üéØ Opportunit√©s":
    st.header("üéØ Analyse des opportunit√©s de diversification")
    
    # Identifier les gaps et opportunit√©s
    st.subheader("üìä Analyse des gaps march√©")
    
    # Calculer les opportunit√©s par cat√©gorie
    cat_analysis = df_formations.groupby('categorie').agg({
        'demand_offres': ['sum', 'mean', 'count'],
        'ratio_demande_etudiants': 'mean'
    }).round(2)
    
    cat_analysis.columns = ['Demande Totale', 'Demande Moyenne', 'Nombre Formations', 'Ratio Moyen']
    cat_analysis['Opportunit√© Score'] = (cat_analysis['Demande Totale'] / cat_analysis['Nombre Formations']) * cat_analysis['Ratio Moyen']
    cat_analysis = cat_analysis.sort_values('Opportunit√© Score', ascending=False)
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üéØ Score d'opportunit√© par cat√©gorie")
        fig, ax = plt.subplots(figsize=(10, 6))
        cat_analysis['Opportunit√© Score'].plot(kind='bar', ax=ax, color='gold')
        ax.set_title("Score d'opportunit√© par cat√©gorie")
        ax.set_xlabel("Cat√©gorie")
        ax.set_ylabel("Score d'opportunit√©")
        plt.xticks(rotation=45)
        plt.tight_layout()
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üéØ Analyse :** Le **score d'opportunit√©** combine la demande totale, 
        le nombre de formations existantes et le ratio demande/√©tudiants. 
        Les cat√©gories avec un score √©lev√© repr√©sentent des **niches sous-servies** 
        avec une forte demande.
        """)
    
    with col2:
        st.subheader("üìà Ratio vs Nombre de formations")
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.scatter(cat_analysis['Nombre Formations'], cat_analysis['Ratio Moyen'], 
                  s=cat_analysis['Demande Totale']/100, alpha=0.7)
        
        # Ajouter les labels des cat√©gories
        for idx, row in cat_analysis.iterrows():
            ax.annotate(idx, (row['Nombre Formations'], row['Ratio Moyen']), 
                       xytext=(5, 5), textcoords='offset points', fontsize=8)
        
        ax.set_title("Ratio vs Nombre de formations (taille = demande)")
        ax.set_xlabel("Nombre de formations")
        ax.set_ylabel("Ratio moyen")
        st.pyplot(fig)
        
        # Analyse d√©taill√©e
        st.markdown("""
        **üìä Analyse :** Les points en **haut √† gauche** repr√©sentent des **opportunit√©s** : 
        peu de formations mais ratio √©lev√©. Les points en **bas √† droite** 
        sont des march√©s **satur√©s** avec beaucoup de concurrence.
        """)
    
    # Recommandations
    st.markdown("---")
    st.subheader("üí° Recommandations strat√©giques")
    
    # Top 3 opportunit√©s
    top_opportunities = cat_analysis.head(3)
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric("ü•á 1√®re Opportunit√©", top_opportunities.index[0])
        st.write(f"Score: {top_opportunities.iloc[0]['Opportunit√© Score']:.1f}")
        st.write(f"Demande: {top_opportunities.iloc[0]['Demande Totale']:.0f} offres")
    
    with col2:
        st.metric("ü•à 2√®me Opportunit√©", top_opportunities.index[1])
        st.write(f"Score: {top_opportunities.iloc[1]['Opportunit√© Score']:.1f}")
        st.write(f"Demande: {top_opportunities.iloc[1]['Demande Totale']:.0f} offres")
    
    with col3:
        st.metric("ü•â 3√®me Opportunit√©", top_opportunities.index[2])
        st.write(f"Score: {top_opportunities.iloc[2]['Opportunit√© Score']:.1f}")
        st.write(f"Demande: {top_opportunities.iloc[2]['Demande Totale']:.0f} offres")
    
    # Analyse d√©taill√©e des recommandations
    st.markdown("""
    **üí° Strat√©gies recommand√©es :**
    
    1. **D√©velopper des formations** dans les cat√©gories avec un score d'opportunit√© √©lev√©
    2. **Cibler les niches** avec peu de concurrence mais forte demande
    3. **Optimiser les formations existantes** dans les march√©s satur√©s
    4. **Surveiller les tendances** pour anticiper les nouveaux besoins
    """)

# Footer
st.markdown("---")
st.markdown("""
<div style='text-align: center; color: #666;'>
    <p>üìä Dashboard d'analyse des tendances de formation digitale | 
    D√©velopp√© avec Streamlit et Matplotlib</p>
</div>
""", unsafe_allow_html=True)
